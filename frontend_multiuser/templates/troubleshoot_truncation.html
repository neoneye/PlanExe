<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Truncation Troubleshooting</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        .back-link {
            margin-bottom: 20px;
            display: inline-block;
            color: #007bff;
            text-decoration: none;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .test-section h3 {
            margin-top: 0;
            color: #555;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .results {
            margin-top: 20px;
        }
        .result-item {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            border-left: 4px solid #007bff;
            background-color: #f8f9fa;
        }
        .result-item.success {
            border-left-color: #28a745;
            background-color: #d4edda;
        }
        .result-item.warning {
            border-left-color: #ffc107;
            background-color: #fff3cd;
        }
        .result-item.error {
            border-left-color: #dc3545;
            background-color: #f8d7da;
        }
        .result-item h4 {
            margin: 0 0 5px 0;
            color: #333;
        }
        .result-item .details {
            font-family: monospace;
            font-size: 0.9em;
            color: #666;
        }
        .progress {
            margin: 10px 0;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 4px;
            display: none;
        }
        .progress-bar {
            width: 0%;
            height: 20px;
            background-color: #007bff;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .progress-text {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }
        .summary {
            margin-top: 20px;
            padding: 15px;
            border-radius: 4px;
            background-color: #e7f3ff;
            border: 1px solid #b3d9ff;
        }
        .summary h3 {
            margin-top: 0;
            color: #0066cc;
        }
        .truncation-detected {
            background-color: #fff3cd;
            border-color: #ffc107;
        }
        .no-truncation {
            background-color: #d4edda;
            border-color: #28a745;
        }
        .format-selector {
            margin: 15px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f8f9fa;
        }
        .format-selector h4 {
            margin: 0 0 10px 0;
            color: #555;
        }
        .format-options {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        .format-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .format-option input[type="radio"] {
            margin: 0;
        }
        .format-option label {
            margin: 0;
            cursor: pointer;
            font-weight: normal;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="/admin" class="back-link">← Back to Admin</a>
        <h1>Truncation Troubleshooting</h1>
        
        <div class="test-section">
            <h3>Test Description</h3>
            <p>This tool tests if the server truncates the <code>prompt</code> parameter around 4000 bytes. 
            It will gradually increase the content length (in bytes) and check if truncation occurs. The test generates realistic content 
            including ASCII, special characters, accented characters, and emojis to properly test byte-based limits.</p>
            
            <div class="format-selector">
                <h4>Request Content Type</h4>
                <div class="format-options">
                    <div class="format-option">
                        <input type="radio" id="formatForm" name="dataFormat" value="form" checked>
                        <label for="formatForm">Form Data</label>
                    </div>
                    <div class="format-option">
                        <input type="radio" id="formatJson" name="dataFormat" value="json">
                        <label for="formatJson">JSON</label>
                    </div>
                </div>
            </div>
            
            <button id="startTest" onclick="startTruncationTest()">Start Truncation Test</button>
            <button id="stopTest" onclick="stopTest()" disabled>Stop Test</button>
        </div>

        <div class="progress" id="progress">
            <div class="progress-bar" id="progressBar"></div>
            <div class="progress-text" id="progressText">Preparing test...</div>
        </div>

        <div class="results" id="results"></div>

        <div class="summary" id="summary" style="display: none;">
            <h3>Test Summary</h3>
            <div id="summaryContent"></div>
        </div>
    </div>

    <script>
        let testRunning = false;
        let testResults = [];
        let currentTestIndex = 0;
        
        // Test sizes in bytes - focusing around 4000 bytes where truncation might occur
        const testSizes = [
            1000, 2000, 3000, 3500, 3750, 3900, 3950, 4000, 4050, 4100, 4250, 4500, 5000, 6000, 8000, 10000, 15000
        ];

        function generateTestContent(sizeInBytes, seed = null) {
            // Use sizeInBytes as seed if no seed provided
            if (seed === null) {
                seed = sizeInBytes;
            }
            
            // Character sets for realistic test content
            const specialChars = "&\"'<>!-_@#$%^*()+=[]{}|\\:;.,?/~`";
            const localizedChars = "æøåÆØÅñÑüÜöÖäÄéÉèÈêÊëËíÍìÌîÎïÏóÓòÒôÔõÕúÚùÙûÛýÝÿŸ";
            // Use a safer set of Unicode characters that are known to be valid
            const unicodeChars = "αβγδεζηθικλμνξοπρστυφχψωΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ";
            
            // Simple deterministic random number generator using seed
            function seededRandom(seed) {
                const x = Math.sin(seed) * 10000;
                return x - Math.floor(x);
            }
            
            // Helper function to get byte length of a string
            function getByteLength(str) {
                return new TextEncoder().encode(str).length;
            }
            
            // Helper function to validate if a character is valid Unicode
            function isValidUnicode(char) {
                try {
                    // Check for invalid surrogate characters
                    const code = char.charCodeAt(0);
                    if (code >= 0xD800 && code <= 0xDFFF) {
                        return false; // Invalid surrogate
                    }
                    
                    // Try to encode the character
                    new TextEncoder().encode(char);
                    return true;
                } catch (e) {
                    return false;
                }
            }
            
            let content = "";
            let currentSeed = seed;
            let retryCount = 0;
            const maxRetries = 10000; // Prevent infinite loops (only increments for invalid chars)
            
            while (getByteLength(content) < sizeInBytes && retryCount < maxRetries) {
                // Generate a random number for character selection
                const rand = seededRandom(currentSeed);
                currentSeed++;
                
                // Choose character set based on random value
                let charSet;
                let char;
                
                if (rand < 0.4) {
                    // 40% chance for regular ASCII letters
                    charSet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
                    char = charSet[Math.floor(rand * 1000) % charSet.length];
                } else if (rand < 0.6) {
                    // 20% chance for special characters
                    charSet = specialChars;
                    char = charSet[Math.floor(rand * 1000) % charSet.length];
                } else if (rand < 0.8) {
                    // 20% chance for localized characters
                    charSet = localizedChars;
                    char = charSet[Math.floor(rand * 1000) % charSet.length];
                } else {
                    // 20% chance for Unicode characters
                    charSet = unicodeChars;
                    char = charSet[Math.floor(rand * 1000) % charSet.length];
                }
                
                // Add character if it's valid Unicode and doesn't exceed byte size limit
                if (isValidUnicode(char) && getByteLength(content + char) <= sizeInBytes) {
                    content += char;
                } else if (!isValidUnicode(char)) {
                    // Skip invalid characters and try again
                    retryCount++;
                    continue;
                } else {
                    break;
                }
            }
            
            return content;
        }

        async function startTruncationTest() {
            if (testRunning) return;
            
            testRunning = true;
            testResults = [];
            currentTestIndex = 0;
            
            document.getElementById('startTest').disabled = true;
            document.getElementById('stopTest').disabled = false;
            document.getElementById('progress').style.display = 'block';
            document.getElementById('results').innerHTML = '';
            document.getElementById('summary').style.display = 'none';
            
            await runTestSequence();
        }

        function stopTest() {
            testRunning = false;
            document.getElementById('startTest').disabled = false;
            document.getElementById('stopTest').disabled = true;
            document.getElementById('progress').style.display = 'none';
            showSummary();
        }

        async function runTestSequence() {
            for (let i = 0; i < testSizes.length && testRunning; i++) {
                currentTestIndex = i;
                const targetSize = testSizes[i];
                
                updateProgress(i, testSizes.length, `Testing ${targetSize} bytes...`);
                
                try {
                    const result = await testParameterSize(targetSize);
                    testResults.push(result);
                    displayResult(result);
                    
                    // Check if we detected truncation
                    if (result.truncated) {
                        // Truncation detected - the result is already displayed by displayResult()
                        // We can break here to stop further testing
                        break;
                    }
                    
                } catch (error) {
                    const errorResult = {
                        targetSize: targetSize,
                        actualSize: 0,
                        truncated: false,
                        error: error.message
                    };
                    testResults.push(errorResult);
                    displayResult(errorResult);
                }
                
                // Small delay between tests
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            if (testRunning) {
                testRunning = false;
                document.getElementById('startTest').disabled = false;
                document.getElementById('stopTest').disabled = true;
                document.getElementById('progress').style.display = 'none';
                showSummary();
            }
        }

        async function testParameterSize(targetSize) {
            const testContent = generateTestContent(targetSize, targetSize);
            const actualSize = new TextEncoder().encode(testContent).length;
            
            // Get the selected data format
            const selectedFormat = document.querySelector('input[name="dataFormat"]:checked').value;
            
            let requestBody;
            let headers = {};
            
            if (selectedFormat === 'json') {
                // Send as JSON
                const jsonData = {
                    prompt: testContent,
                    user_agent: navigator.userAgent,
                    timestamp_unix: Date.now(),
                    timestamp_utc: new Date().toISOString()
                };
                requestBody = JSON.stringify(jsonData);
                headers['Content-Type'] = 'application/json';
            } else {
                // Send as form data (default)
                const formData = new FormData();
                formData.append('prompt', testContent);
                formData.append('user_agent', navigator.userAgent);
                formData.append('timestamp_unix', Date.now());
                formData.append('timestamp_utc', new Date().toISOString());
                requestBody = formData;
            }
            
            const response = await fetch('/troubleshoot_truncation_echo', {
                method: 'POST',
                headers: headers,
                body: requestBody
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const result = await response.json();
            const receivedContent = result.prompt || '';
            const receivedSize = new TextEncoder().encode(receivedContent).length;
            
            const truncated = receivedSize < actualSize;
            console.log(`=== Test ${targetSize} bytes ===`);
            console.log(`Target size: ${targetSize}`);
            console.log(`Actual size sent: ${actualSize} bytes`);
            console.log(`Received content: ${receivedContent.length} characters`);
            console.log(`Received size: ${receivedSize} bytes`);
            console.log(`Truncated: ${truncated}`);
            console.log(`========================`);
            
            return {
                targetSize: targetSize,
                actualSize: actualSize,
                receivedSize: receivedSize,
                truncated: truncated,
                response: result
            };
        }

        function displayResult(result) {
            const resultsDiv = document.getElementById('results');
            const resultDiv = document.createElement('div');
            
            let statusClass = 'success';
            let statusText = '✓';
            let details = `Send: ${result.actualSize} bytes, Received: ${result.receivedSize} bytes`;
            
            if (result.error) {
                statusClass = 'error';
                statusText = '✗';
                details = `Error: ${result.error}`;
            } else if (result.truncated) {
                statusClass = 'warning';
                statusText = '⚠️';
                details = `TRUNCATED! Send: ${result.actualSize} bytes, Received: ${result.receivedSize} bytes (${result.actualSize - result.receivedSize} bytes lost)`;
            }
            
            resultDiv.className = `result-item ${statusClass}`;
            resultDiv.innerHTML = `
                <h4>${statusText} Test ${result.targetSize} bytes</h4>
                <div class="details">${details}</div>
            `;
            
            resultsDiv.appendChild(resultDiv);
        }

        function updateProgress(current, total, text) {
            const percentage = (current / total) * 100;
            document.getElementById('progressBar').style.width = percentage + '%';
            document.getElementById('progressText').textContent = text;
        }

        function showSummary() {
            const summaryDiv = document.getElementById('summary');
            const summaryContent = document.getElementById('summaryContent');
            
            let summaryHtml = '';
            let hasTruncation = false;
            let truncationPoint = null;
            
            console.log('Test results:', testResults);
            
            for (const result of testResults) {
                console.log(`Checking result: targetSize=${result.targetSize}, truncated=${result.truncated}`);
                if (result.truncated) {
                    hasTruncation = true;
                    truncationPoint = result.targetSize;
                    console.log(`Truncation detected at ${truncationPoint} bytes`);
                    break;
                }
            }
            
            console.log(`Summary: hasTruncation=${hasTruncation}, truncationPoint=${truncationPoint}`);
            
            if (hasTruncation) {
                summaryDiv.className = 'summary truncation-detected';
                summaryHtml = `
                    <p><strong>⚠️ Truncation Detected!</strong></p>
                    <p>Parameter truncation was detected at approximately <strong>${truncationPoint} bytes</strong>.</p>
                    <p>This confirms that the /run endpoint truncates the prompt parameter.</p>
                    <p><strong>Recommendation:</strong> Investigate the web server configuration, proxy settings, or form data limits that might be causing this truncation.</p>
                `;
            } else {
                summaryDiv.className = 'summary no-truncation';
                summaryHtml = `
                    <p><strong>✓ No Truncation Detected</strong></p>
                    <p>No parameter truncation was detected in the tested range (up to ${Math.max(...testSizes)} bytes).</p>
                    <p>This suggests that the /run endpoint is not truncating parameters in the tested size range.</p>
                    <p><strong>Note:</strong> If someone reported truncation at 15KB, you may want to test with larger sizes or investigate other potential causes.</p>
                `;
            }
            
            summaryContent.innerHTML = summaryHtml;
            summaryDiv.style.display = 'block';
        }
    </script>
</body>
</html>
